#!/usr/bin/env bash
set -euo pipefail

# Generated helper to make this Oracle fork usable from any directory by:
# - Installing a Codex skill (copied files) at ~/.codex/skills/oracle
# - Installing wrapper commands on PATH (oracle-local / oracle-mcp-local)
#
# Safe by default: refuses to overwrite non-generated wrapper scripts.

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
MARKER="# Generated by oracle/scripts/setup-local-agent.sh"

usage() {
  cat <<'EOF'
Usage: ./scripts/setup-local-agent.sh [--chatgpt-url <url>]

Options:
  --chatgpt-url <url>  Set ~/.oracle/config.json browser.chatgptUrl to a ChatGPT project/workspace URL.
  -h, --help           Show this help.
EOF
}

choose_bin_dir() {
  local candidates=("$HOME/bin" "$HOME/.local/bin")
  for candidate in "${candidates[@]}"; do
    if [[ ":${PATH:-}:" == *":${candidate}:"* ]]; then
      printf '%s' "$candidate"
      return 0
    fi
  done
  printf '%s' "$HOME/bin"
}

install_codex_skill() {
  local codex_home="${CODEX_HOME:-$HOME/.codex}"
  local skills_dir="$codex_home/skills"
  local target="$ROOT_DIR/skills/oracle"
  local dest="$skills_dir/oracle"
  local marker_file="$dest/.oracle-skill-install.marker"

  mkdir -p "$skills_dir"

  if [[ -L "$dest" ]]; then
    rm "$dest"
  fi

  if [[ -e "$dest" && ! -d "$dest" ]]; then
    echo "[setup] Refusing to replace existing non-directory: $dest" >&2
    return 1
  fi

  if [[ -d "$dest" ]]; then
    if [[ -f "$marker_file" ]] && grep -qF "$MARKER" "$marker_file"; then
      rm -rf "$dest"
    else
      echo "[setup] Refusing to overwrite existing Codex skill directory: $dest" >&2
      echo "[setup] Remove it manually (or add the marker file) if you want this script to manage it." >&2
      return 1
    fi
  fi

  mkdir -p "$dest"
  cp -R "$target"/. "$dest"
  printf '%s\n' "$MARKER" >"$marker_file"
  echo "[setup] Installed Codex skill files: $dest"
}

update_oracle_chatgpt_url() {
  local url="$1"
  local oracle_dir="$HOME/.oracle"
  local config_path="$oracle_dir/config.json"

  if [[ -z "${url// }" ]]; then
    echo "[setup] --chatgpt-url is empty; skipping config update." >&2
    return 1
  fi

  mkdir -p "$oracle_dir"

  (cd "$ROOT_DIR" && ORACLE_CONFIG_PATH="$config_path" ORACLE_CHATGPT_URL="$url" node --input-type=module - <<'NODE'
import fs from 'node:fs';
import path from 'node:path';

const configPath = process.env.ORACLE_CONFIG_PATH;
const url = process.env.ORACLE_CHATGPT_URL;
if (!configPath || !url) {
  process.exit(1);
}

let JSON5 = null;
try {
  JSON5 = (await import('json5')).default;
} catch {
  JSON5 = null;
}

const hadExistingConfig = fs.existsSync(configPath);
let raw = '{}';
try {
  raw = fs.readFileSync(configPath, 'utf8');
} catch (error) {
  if (hadExistingConfig) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`[setup] Failed to read existing config file: ${configPath}`);
    console.error(`[setup] ${message}`);
    console.error('[setup] Refusing to overwrite an unreadable config file.');
    process.exit(1);
  }
}

let config = {};
try {
  config = JSON5 ? JSON5.parse(raw) : JSON.parse(raw);
} catch {
  if (hadExistingConfig && raw.trim().length > 0) {
    const parserHint = JSON5
      ? 'Failed to parse ~/.oracle/config.json as JSON5.'
      : 'Failed to parse ~/.oracle/config.json as JSON, and the optional "json5" dependency was not available.';
    console.error(`[setup] ${parserHint}`);
    console.error('[setup] Refusing to overwrite an unparseable config file.');
    console.error('[setup] Fix the file or run this from the repo after `pnpm install` so JSON5 parsing is available.');
    process.exit(1);
  }
  config = {};
}

const browser = (config.browser && typeof config.browser === 'object') ? config.browser : {};
browser.chatgptUrl = url;
// Keep legacy alias unset to avoid ambiguity (chatgptUrl wins).
if ('url' in browser) {
  delete browser.url;
}
config.browser = browser;

fs.mkdirSync(path.dirname(configPath), { recursive: true });
fs.writeFileSync(configPath, `${JSON.stringify(config, null, 2)}\n`, 'utf8');
console.log(`[setup] Updated ${configPath}: browser.chatgptUrl=${url}`);
NODE
  )
}

write_wrapper() {
  local bin_dir="$1"
  local filename="$2"
  local entry_rel="$3"
  local out="$bin_dir/$filename"

  mkdir -p "$bin_dir"

  if [[ -e "$out" && ! -f "$out" ]]; then
    echo "[setup] Refusing to overwrite non-file: $out" >&2
    return 1
  fi
  if [[ -f "$out" ]] && ! grep -qF "$MARKER" "$out"; then
    echo "[setup] Refusing to overwrite non-generated wrapper: $out" >&2
    echo "[setup] (Move it aside or delete it, then rerun.)" >&2
    return 1
  fi

  cat >"$out" <<EOF
#!/usr/bin/env bash
set -euo pipefail
$MARKER

ORACLE_REPO="\${ORACLE_REPO:-$ROOT_DIR}"
ENTRY="\$ORACLE_REPO/$entry_rel"

if [[ ! -d "\$ORACLE_REPO" ]]; then
  echo "[oracle-local] ORACLE_REPO not found: \$ORACLE_REPO" >&2
  exit 1
fi

if [[ ! -f "\$ENTRY" ]]; then
  echo "[oracle-local] Missing build artifact: \$ENTRY" >&2
  echo "[oracle-local] Run: (cd \"\$ORACLE_REPO\" && pnpm install && pnpm build)" >&2
  exit 1
fi

exec node "\$ENTRY" "\$@"
EOF

chmod +x "$out"
  echo "[setup] Installed wrapper: $out"
}

main() {
  local chatgpt_url=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --chatgpt-url)
        chatgpt_url="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        echo "[setup] Unknown argument: $1" >&2
        usage >&2
        exit 1
        ;;
    esac
  done

  local bin_dir
  bin_dir="$(choose_bin_dir)"

  install_codex_skill
  write_wrapper "$bin_dir" "oracle-local" "dist/bin/oracle-cli.js"
  write_wrapper "$bin_dir" "oracle-mcp-local" "dist/bin/oracle-mcp.js"
  if [[ -n "${chatgpt_url// }" ]]; then
    update_oracle_chatgpt_url "$chatgpt_url"
  fi

  echo "[setup] Done."
  echo "[setup] Next:"
  echo "  - oracle-local --help"
  echo "  - oracle-local --engine browser --model gpt-5.2-pro --browser-model-strategy select -p \"hello\""
  echo "  - (API) export OPENAI_API_KEY=... then oracle-local --engine api --model gpt-5.2-pro --wait -p \"hello\""
}

main "$@"
